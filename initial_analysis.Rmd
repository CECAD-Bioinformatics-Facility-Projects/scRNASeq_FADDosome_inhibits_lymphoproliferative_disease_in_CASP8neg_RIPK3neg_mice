---
title: "Single-Cell RNA-Seq analysis of BTLA immune cells in the spleen of RIPK3-/- Casp8CS/CS mice"
author:
  - name: "Dr. Ali T. Abdallah"
    email: "ali.abdallah@uni-koeln.de"
    affiliation: "CECAD Research Center - Bioinformatics Facility"
date: "2025-05-08"
version: "1.0"
site: bookdown::bookdown_site
output:
  rmdformats::readthedown:
    toc_depth: 3
---

# Project description

```{r setup, echo=F, include=F}
library(targets)
library(Seurat)
library(future) 
library(dplyr)
library(cowplot)
library(ggplot2)
library(DESeq2)
library(limma)
library(tibble)
library(rrvgo)
library(org.Hs.eg.db)
source("R/helper.R")
source("R/pseudobulk_dea.R")
source("R/annotation_by_reference.R")
source("R/sc_workflow.R")
run <- FALSE
```

```{r read_sample, echo=F, include=F}
run <- FALSE
if(run){
  n <- 9
  sample_names <- list("CSR1", "CSR2", "WTR1", "WTR2", "WTR3", "WTR4", "CSR3", "KOR1", "KOR2")
  seurat_objects <- vector("list", n)
  for(i in 1:n){
    target_name <- (paste0("SO_UMAP_",sample_names[[i]]))
    seurat_objects[[i]] <- tar_read_raw(target_name)
    seurat_objects[[i]]$orig.ident <- sample_names[[i]]
  }
  names(seurat_objects) <- sample_names
  dim_plots <- vector("list", n)
  for(i in 1:n){
    dim_plots[[i]] <- DimPlot(seurat_objects[[i]], reduction = "umap") + ggtitle(sample_names[[i]])
  }
  dim_plots
}
```

## Integration

We integrate all samples to form one dataset for downstream analysis. For this
purpose we use the starndard procedure of Seurat. We first normalize and identify
variable features for each dataset independently. Then we select features that are
repeatedly variable across datasets for integration and run PCA on each dataset
using these features. We then select integration features and find integration
anchors. We create an 'integrated' data assay and specify that we will perform
downstream analysis on the corrected data. We run the standard workflow for
visualization and clustering.

```{r umap, fig.width=20, fig.height=5, include=F, echo=F}
if(run){
  # load dataset
  # normalize and identify variable features for each dataset independently
  seurat_objects <- lapply(X = seurat_objects, FUN = function(x) {
      x <- NormalizeData(x)
      x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 2000)
  })
  
  # select features that are repeatedly variable across datasets for integration 
  # run PCA on each dataset using these features
  features <- SelectIntegrationFeatures(object.list = seurat_objects)
  seurat_objects <- lapply(X = seurat_objects, FUN = function(x) {
      x <- ScaleData(x, features = features, verbose = FALSE)
      x <- RunPCA(x, features = features, verbose = FALSE)
  })
  
  seurat_objects.anchors <- 
    FindIntegrationAnchors(object.list = seurat_objects,
                           anchor.features = features,
                           reduction = "rpca")
  
  # this command creates an 'integrated' data assay
  seurat_objects.combined <- IntegrateData(anchorset = seurat_objects.anchors)
  # specify that we will perform downstream analysis on the corrected data note 
  # that the original unmodified data still resides in the 'RNA' assay
  DefaultAssay(seurat_objects.combined) <- "integrated"
  
  # Run the standard workflow for visualization and clustering
  seurat_objects.combined <- ScaleData(seurat_objects.combined, 
                                       verbose = FALSE)
  
  seurat_objects.combined <- RunPCA(seurat_objects.combined, 
                                    npcs = 30, 
                                    verbose = FALSE)
  
  seurat_objects.combined <- RunUMAP(seurat_objects.combined, 
                                     reduction = "pca", 
                                     dims = 1:30)
  
  seurat_objects.combined <- FindNeighbors(seurat_objects.combined, 
                                           reduction = "pca", 
                                           dims = 1:30)
  

  qs::qsave(seurat_objects.combined, file = "results/seurat_objects.combined.qs")
} else {
  seurat_objects.combined <- qs::qread(file="results/seurat_objects.combined.qs")
}
if(run){
  res_list <- c(0.0125, 0.025, 0.05, 0.1, 0.5)
  for(res in res_list){
    print(paste0("Resolution: ", res))
      seurat_objects.combined <- 
      FindClusters(seurat_objects.combined, resolution = as.numeric(res))
  }
  qs::qsave(seurat_objects.combined, file = "results/seurat_objects.combined.clustering.qs")
} else {
  seurat_objects.combined <- qs::qread(file="results/seurat_objects.combined.clustering.qs")
}
```


```{r QC, fig.height=5, fig.width=15, echo=F}
DefaultAssay(seurat_objects.combined) <- "RNA"
seurat_objects.combined@meta.data$percent.mt <- 
  PercentageFeatureSet(seurat_objects.combined, pattern = "^mt-")
Idents(seurat_objects.combined) <- "integrated_snn_res.0.5"
VlnPlot(seurat_objects.combined %>% 
          subset(subset=percent.mt <= 5 & nFeature_RNA > 200),
        features = c("nFeature_RNA", "nCount_RNA", "percent.mt"),
        pt.size = 0.0) + 
  NoLegend()
```

## Doublet detection
```{r doublet_detection, fig.width=15, fig.height=5, echo=F}
if(run){
  # Load required libraries
  library(Seurat)                # For single-cell analysis
  library(scDblFinder)           # For doublet detection (see: https://github.com/MarioniLab/scDblFinder)
  library(SingleCellExperiment)  # For conversion between Seurat and SCE objects
  library(ggplot2)               # For visualization (DimPlot uses ggplot2)
  # Convert the Seurat object to a SingleCellExperiment (SCE) object
  # scDblFinder requires an SCE object as input
  seurat_objects.combined[["RNA"]] <- JoinLayers(seurat_objects.combined[["RNA"]])
  DefaultAssay(seurat_objects.combined) <- "RNA"
  sce <- as.SingleCellExperiment(seurat_objects.combined)
  # Run scDblFinder to detect doublets
  # 'samples' argument is set to the "orig.ident" column to account for multiple sample identities
  sce <- scDblFinder(sce, samples = "orig.ident", clusters = "integrated_snn_res.0.5")
  # Extract scDblFinder results and add them back to the Seurat object metadata
  # The scDblFinder output includes columns like 'scDblFinder.class' (doublet/singlet prediction)
  doublet_info <- as.data.frame(colData(sce))
  doublet_info <- doublet_info[, grepl("^scDblFinder", colnames(doublet_info))]
  rownames(doublet_info) <- colnames(seurat_objects.combined)
  seurat_objects.combined <- AddMetaData(seurat_objects.combined, metadata = doublet_info)
  # Visualize doublet predictions
  qs::qsave(seurat_objects.combined, file = "results/seurat_objects.combined.clusterin.doublet_info.qs")
} else {
  seurat_objects.combined <- qs::qread(file="results/seurat_objects.combined.clusterin.doublet_info.qs")
}

seurat_objects.combined %>% DimPlot(split.by = "scDblFinder.class") + NoLegend()
```

## Removal of doublet and low-quality Cells
```{r doulet_and_low_quality_removal, fig.width=15, fig.height=5, echo=F}
if(run){
  seurat_objects.combined <-
    subset(seurat_objects.combined, subset = scDblFinder.class == "singlet")
  seurat_objects.combined <-
    subset(seurat_objects.combined,
           subset = percent.mt <= 5 &
             nFeature_RNA > 200 &
             nFeature_RNA < 5000)
  
  seurat_objects.combined <-
    subset(seurat_objects.combined, subset = seurat_clusters!=29)
  DefaultAssay(seurat_objects.combined) <- "integrated"
  seurat_objects.combined
  seurat_objects.combined <- NormalizeData(seurat_objects.combined)
  seurat_objects.combined <- ScaleData(seurat_objects.combined)
  seurat_objects.combined <- RunPCA(seurat_objects.combined, npcs = 100)
  
  DefaultAssay(seurat_objects.combined) <- "integrated" 
  seurat_objects.combined <-
    JackStraw(seurat_objects.combined, dims=50, reduction = "pca")
  seurat_objects.combined <-
    ScoreJackStraw(seurat_objects.combined, dims = 1:50)
  JackStrawPlot(seurat_objects.combined, dims = 1:50) + xlim(0,1)
  qs::qsave(seurat_objects.combined,
            file="results/seurat_objects.combined.doublet_removed.jackstraw.qs")
} else {
  seurat_objects.combined <-
    qs::qread(file="results/seurat_objects.combined.doublet_removed.jackstraw.qs")
}
```


## Clustering (Resolution 0.1)
```{r clustering_level1, fig.width=8, fig.height=5, echo=F}
if(run){
options(future.globals.maxSize = 5120 * 1024^2)  # 5 GiB
ElbowPlot(seurat_objects.combined, ndims = 100)
seurat_objects.combined <- FindNeighbors(seurat_objects.combined, dims = 1:60)
seurat_objects.combined <- FindClusters(seurat_objects.combined, resolution = 0.1)
seurat_objects.combined <- RunUMAP(seurat_objects.combined, dims = 1:60)

# for(res in c(0.0125, 0.025, 0.05, 0.1, 0.5)){
#   print(paste0("Resolution: ", res))
#   seurat_objects.combined <- FindClusters(seurat_objects.combined, resolution = res)
# }

qs::qsave(seurat_objects.combined, file="results/seurat_objects.combined.doublet_removed.jackstraw.reclustered.qs")

} else {
  seurat_objects.combined <- qs::qread(file="results/seurat_objects.combined.doublet_removed.jackstraw.reclustered.qs")
}

Idents(seurat_objects.combined) <- "integrated_snn_res.0.1"
DefaultAssay(seurat_objects.combined) <- "RNA"

DimPlot(seurat_objects.combined,
        group.by = "integrated_snn_res.0.1", label = TRUE) +
  NoLegend() +
  theme(axis.line =element_blank(),
        axis.ticks = element_blank(),
        axis.text = element_blank()) +
  ggtitle("UMAP plot of integrated dataset - Resolution 0.1")
```

## Clustering refinement
```{r clustering_level2, fig.width=8, fig.height=5, echo=F}


seurat_objects.combined <- 
  FindSubCluster(seurat_objects.combined,
                 cluster = 4,
                 resolution = 0.05,
                 graph.name = "integrated_snn",
                 subcluster.name = "integrated_snn_res.0.1_and_cluster_4")

Idents(seurat_objects.combined) <- "integrated_snn_res.0.1_and_cluster_4"
seurat_objects.combined <- 
  FindSubCluster(seurat_objects.combined,
                 cluster = 7,
                 resolution = 0.05,
                 graph.name = "integrated_snn",
                 subcluster.name = "integrated_snn_res.0.1_and_cluster_4_and_cluster_9")

DimPlot(seurat_objects.combined,
        group.by = "integrated_snn_res.0.1_and_cluster_4_and_cluster_9", label = TRUE) +
  NoLegend() +
  theme(axis.line =element_blank(),
        axis.ticks = element_blank(),
        axis.text = element_blank()) +
  ggtitle("UMAP plot of integrated dataset - Resolution 0.1")
```


## Marker detection
```{r marker_detection, echo=F}
Idents(seurat_objects.combined) <- 
  "integrated_snn_res.0.1_and_cluster_4_and_cluster_9"
resolution_list <- c(0.025, 0.05, 0.075, 0.1, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5)
markers <- vector("list", length(resolution_list))
names(markers) <- paste0("res.", resolution_list)

if(run){

markers[["res.0.1"]] <- FindAllMarkers(seurat_objects.combined,
                                       only.pos = TRUE,
                                       min.pct = 0.25,
                                       logfc.threshold = log2(1.5))

qs::qsave(markers, file="results/markers_integrated_snn_res.0.1_and_cluster_4_and_cluster_9.qs")
} else {
  markers <- qs::qread(file="results/markers_integrated_snn_res.0.1_and_cluster_4_and_cluster_9.qs")
}
top_markers <-
  markers[["res.0.1"]] %>%
  dplyr::filter(avg_log2FC > 1 & p_val_adj < .05) %>%
  dplyr::arrange(cluster, desc(avg_log2FC))


seurat_objects.combined@meta.data$integrated_snn_res.0.1_and_cluster_4_and_cluster_9.char <- paste0("cluster_",seurat_objects.combined@meta.data$integrated_snn_res.0.1_and_cluster_4_and_cluster_9)

ident.2 <- seurat_objects.combined$integrated_snn_res.0.1_and_cluster_4_and_cluster_9.char[!seurat_objects.combined$integrated_snn_res.0.1_and_cluster_4_and_cluster_9.char %in% c("cluster_0", "cluster_4_1", "cluster_4_2", "cluster_13")] %>% unique

if(run){
m_4_2 <- FindMarkers(seurat_objects.combined, group.by="integrated_snn_res.0.1_and_cluster_4_and_cluster_9.char", ident.1 = "cluster_4_2", ident.2 =ident.2 , min.pct = 0.25, logfc.threshold = log2(1.5))
top_4_2 <- m_4_2 %>% dplyr::filter(avg_log2FC > 1 & p_val_adj < .05) %>% dplyr::arrange(desc(avg_log2FC))
m_4_1 <- FindMarkers(seurat_objects.combined, group.by="integrated_snn_res.0.1_and_cluster_4_and_cluster_9.char", ident.1 = "cluster_4_1", ident.2 =ident.2 , min.pct = 0.25, logfc.threshold = log2(1.5))
top_4_1 <- m_4_1 %>% dplyr::filter(avg_log2FC > 1 & p_val_adj < .05) %>% dplyr::arrange(desc(avg_log2FC))
m_13 <- FindMarkers(seurat_objects.combined, group.by="integrated_snn_res.0.1_and_cluster_4_and_cluster_9.char", ident.1 = "cluster_13", ident.2 =ident.2 , min.pct = 0.25, logfc.threshold = log2(1.5))
top_13 <- m_13 %>% dplyr::filter(avg_log2FC > 1 & p_val_adj < .05) %>% dplyr::arrange(desc(avg_log2FC))
ident.2.T <- seurat_objects.combined$integrated_snn_res.0.1_and_cluster_4_and_cluster_9.char[!seurat_objects.combined$integrated_snn_res.0.1_and_cluster_4_and_cluster_9.char %in% c("cluster_1",  "cluster_7_1", "cluster_2", "cluster_3", "cluster_12", "cluster_4_0")] %>% unique
m_4_0 <- FindMarkers(seurat_objects.combined, group.by="integrated_snn_res.0.1_and_cluster_4_and_cluster_9.char", ident.1 = "cluster_4_0", ident.2 =ident.2.T , min.pct = 0.25, logfc.threshold = log2(1.5))
top_4_0 <- m_4_0 %>% dplyr::filter(avg_log2FC > 1 & p_val_adj < .05) %>% dplyr::arrange(desc(avg_log2FC))
 
special_top_markers_list <- list(cluster_4_0 = top_4_0 %>% add_column(gene=rownames(.)), 
                                 cluster_4_1 = top_4_1 %>% add_column(gene=rownames(.)),
                                 cluster_4_2 = top_4_2 %>% add_column(gene=rownames(.)),
                                 cluster_13 = top_13 %>% add_column(gene=rownames(.)))

qs::qsave(special_top_markers_list, file="results/special_top_markers_list.qs")
} else {
  special_top_markers_list <- qs::qread(file="results/special_top_markers_list.qs")
}


top_markers_list <-
  top_markers %>%
  dplyr::arrange(desc(avg_log2FC)) %>%
  dplyr::group_split(cluster)

names(top_markers_list) <- paste0("cluster_",
                                  c("4_0", "5", "9", "6", "2", "1", "11",
                                    "3", "0", "8", "7_1", "4_2", "10",
                                    "12", "7_0", "13", "4_1") %>%
                                    as.character())
```

## Annotation

### Immgen Database
```{r echo=F, fig.width=20, fig.height=10, inlcude=F}
library(celldex)

if(run){
immgen_data <- celldex::ImmGenData()
colData(immgen_data)
logcounts_mat <- assay(immgen_data, "logcounts")
# Convert back to counts (assuming log2(count + 1) transformation)
counts_mat <- 2^logcounts_mat - 1
# Optionally, add the recovered counts as a new assay in the SummarizedExperiment object
assay(immgen_data, "counts") <- round(counts_mat)
immgen_so <- CreateSeuratObject(counts = assay(immgen_data, "counts"),
                                meta.data = as.data.frame(colData(immgen_data)))
immgen_so <- NormalizeData(immgen_so)
immgen_so <- FindVariableFeatures(immgen_so, selection.method = "vst", nfeatures = 2000)
immgen_so <- ScaleData(immgen_so)
immgen_so <- RunPCA(immgen_so, npcs = 100)
ElbowPlot(immgen_so, ndims=100)
immgen_so <- FindNeighbors(immgen_so, dims = 1:50)
immgen_so <- FindClusters(immgen_so, resolution = 0.1)
immgen_so <- RunUMAP(immgen_so, dims = 1:50)

DimPlot(immgen_so, group.by = "label.main", label = TRUE) + NoLegend()

immgen_so_T <- subset(immgen_so, idents = c("T cells"))
immgen_so_T <- NormalizeData(immgen_so_T)
immgen_so_T <- FindVariableFeatures(immgen_so_T, selection.method = "vst", nfeatures = 2000)
immgen_so_T <- ScaleData(immgen_so_T)
immgen_so_T <- RunPCA(immgen_so_T, npcs = 100)
ElbowPlot(immgen_so_T, ndims=100)
immgen_so_T <- FindNeighbors(immgen_so_T, dims = 1:50)
immgen_so_T <- FindClusters(immgen_so_T, resolution = 0.1)
immgen_so_T <- RunUMAP(immgen_so_T, dims = 1:50)


immgen_so_B <- subset(immgen_so, idents = c("B cells"))
immgen_so_B <- NormalizeData(immgen_so_B)
immgen_so_B <- FindVariableFeatures(immgen_so_B, selection.method = "vst", nfeatures = 2000)
immgen_so_B <- ScaleData(immgen_so_B)
immgen_so_B <- RunPCA(immgen_so_B, npcs = 50)
ElbowPlot(immgen_so_B, ndims=50)
immgen_so_B <- FindNeighbors(immgen_so_B, dims = 1:20)
immgen_so_B <- FindClusters(immgen_so_B, resolution = 0.1)
immgen_so_B <- RunUMAP(immgen_so_B, dims = 1:20)

qs::qsave(immgen_so, file="results/immgen_so.qs")
qs::qsave(immgen_so_T, file="results/immgen_so_T.qs")
qs::qsave(immgen_so_B, file="results/immgen_so_B.qs")
} else {
  immgen_so <- qs::qread(file="results/immgen_so.qs")
  immgen_so_T <- qs::qread(file="results/immgen_so_T.qs")
  immgen_so_B <- qs::qread(file="results/immgen_so_B.qs")
}

Idents(immgen_so) <- "label.main"

if(run){
markers_immgen <-
  FindAllMarkers(immgen_so,
                 only.pos = TRUE,
                 min.pct = 0.25,
                 logfc.threshold = log2(1.5))
qs::qsave(markers_immgen, file="results/markers_immgen.qs")
} else {
  markers_immgen <- qs::qread(file="results/markers_immgen.qs")
}

top_markers_immgen <- 
  markers_immgen %>% 
  dplyr::filter(p_val_adj < 0.05 & avg_log2FC > 1) %>%
  group_by(cluster) %>% top_n(100, avg_log2FC) %>%
  ungroup() %>%
  arrange(cluster, desc(avg_log2FC))

seurat_obj <- immgen_so
#Print the combined plot
label.main <- c("Macrophages" , "Monocytes",  "B cells" , "DC", "Stromal cells",
  "Eosinophils", "Fibroblasts", "Neutrophils", "Endothelial cells" , "T cells",
 "ILC",  "NK cells", "Basophils", "Epithelial cells", "Mast cells"      , 
 "Stem cells", "Tgd", "NKT",    "B cells, pro"  ,    "Microglia"  )

label.main.short <- 
  c("MF", "Mono", "B", "DC", "Stromal", "Eosino", "Fibro", "Neutro", "Endo", 
    "T", "ILC", "NK", "Baso", "Epithelial", "Mast", "Stem", "Tgd", "NKT", 
    "B (pro)", "Microglia")

map <- setNames(label.main.short,label.main)
immgen_so@meta.data$label.main.short <- map[immgen_so@meta.data$label.main]
label.top <- c("MF", "Mono", "B", "DC", "Stromal", "Eosino", "Fibro",
               "Neutro", "Endo", "T", "ILC", "NK", "Baso", "Epithelial", 
               "Mast", "Stem", "T", "T", "B (pro)", "Microglia")
map <- setNames(label.top, label.main.short)
seurat_obj@meta.data$label.top <- map[seurat_obj@meta.data$label.main.short]
```

```{r fig.width=20, fig.height=10, echo=F, include=F}
cowplot::plot_grid(
  DimPlot(seurat_obj,
          group.by = "label.main.short",
          pt.size = 3,
          label = TRUE) + 
    NoLegend() + 
    ggtitle("All samples"),
  DimPlot(immgen_so_T,
          group.by = "label.fine",
          pt.size = 3,
          label = TRUE) +
    NoLegend() + 
    ggtitle("T cells"),
  ncol=2)

```

```{r echo=F, fig.width=10, fig.height=5, include=F, warning=F, message=F}
## UMAPs
# <h4>Batch effect: batches and technology</h4>
# The integration worked fine, as we can see in the following plots.

    seurat_objects.combined@meta.data <- 
      seurat_objects.combined@meta.data %>%
      mutate(batch = case_when(
        orig.ident %in% c("WTR1", "WTR2", "CSR1") ~ "batch1",
        orig.ident %in% c("WTR3", "CSR2") ~ "batch2",
        orig.ident %in% c("WTR4", "CSR3", "KOR1", "KOR2") ~ "batch3"
      ))
    
    seurat_objects.combined@meta.data <- 
      seurat_objects.combined@meta.data %>%
      mutate(technology = case_when(
        orig.ident %in% c("WTR1", "WTR2", "CSR1") ~ "singleron",
        orig.ident %in% c("WTR3", "CSR2") ~ "tenX",
        orig.ident %in% c("WTR4", "CSR3", "KOR1", "KOR2") ~ "tenX"
      ))
  
DimPlot(seurat_objects.combined, label=T, pt.size=2, split.by = "batch") + theme_void() + ggtitle("Batch")
DimPlot(seurat_objects.combined, label=T, pt.size=1, split.by = "technology") + theme_void() + ggtitle("Technology")
```


# Annotation

To classify different cell types, we employ a reference-based method and complete
this by manual confirmation when needed. In the context of scRNA-Seq data 
analysis using Seurat,the described process involves transfering markers from 
the studied dataset to a reference dataset for cell type recognition. For this
purpose, we download the ImmGen dataset using the R package celldex.

In the following we provide for each cluster the evidence for its annotation.

```{r echo=F, include=F}
source("R/annotation_by_reference.R")
cls <- c("4_0", "5", "9", "6", "2", "1", "11",
         "3", "0", "8", "7_1", "4_2", "10",
         "12", "7_0", "13", "4_1")

results_of_annotation_by_reference <- list()

for(i in 1:length(cls)){
  print(paste0("cluster_",cls[i]))
  # Example usage:
  results_of_annotation_by_reference[[paste0("cluster_",cls[i])]] <- 
    compute_module_scores_and_pairwise_plots(
      seurat_obj,
      top_markers_list,
      cluster_name = paste0("cluster_",cls[i]),
      prefix = "CellTypeScore",
      group.by = "label.top")
}
#names(results_of_annotation_by_reference[[paste0("cluster_4_0")]])
#results_of_annotation_by_reference[[paste0("cluster_4_0")]][["top_markers"]] %>% pull(gene)
#results_of_annotation_by_reference[[paste0("cluster_4_0")]][["combined_plot"]]
#compute_module_scores_and_pairwise_plots(immgen_so_B, top_markers_list, cluster_name = "cluster_4_1", prefix = "CellTypeScore", group.by = "label.fine")
#compute_module_scores_and_pairwise_plots(immgen_so_B, top_markers_list, cluster_name = "cluster_4_2", prefix = "CellTypeScore", group.by = "label.fine")
#seurat_objects.combined@meta.data$integrated_snn_res.0.1_and_cluster_4_and_cluster_9.char <- paste0("cluster_",seurat_objects.combined@meta.data$integrated_snn_res.0.1_and_cluster_4_and_cluster_9)
#compute_module_scores_and_pairwise_plots(seurat_objects.combined, top_markers_list_T, cluster_name = "ISP", prefix = "CellTypeScore", group.by = "integrated_snn_res.0.1_and_cluster_4_and_cluster_9.char")
#compute_module_scores_and_pairwise_plots(seurat_objects.combined, top_markers_list_T, cluster_name = "ISP.all", prefix = "CellTypeScore", group.by = "integrated_snn_res.0.1_and_cluster_4_and_cluster_9.char")
#compute_module_scores_and_pairwise_plots(immgen_so_T, top_markers_list, cluster_name = "cluster_4_0", prefix = "CellTypeScore", group.by = "label.fine")
#FeaturePlot(seurat_objects.combined, features="Tcf7", min.cutoff = .1)

special_results_of_annotation_by_reference <- list()

for(name in names(special_top_markers_list)){
  print(name)
  # Example usage:
  special_results_of_annotation_by_reference[[name]] <- 
    compute_module_scores_and_pairwise_plots(
      seurat_obj,
      special_top_markers_list,
      cluster_name = name,
      prefix = "CellTypeScore",
      group.by = "label.top")
}

```

## B cells

Cluster 0, 4_1, 4_2, 13 are B cells. 

### Known markers
```{r echo=F, fig.width=20, fig.height=5}
cowplot::plot_grid(FeaturePlot(seurat_objects.combined, min.cutoff = .1,
            features = c("Cd79a"), label=T),
VlnPlot(seurat_objects.combined, pt.size=0, features=c("Cd19","Cd79a", "Ms4a1", "Cd22", "Pax5"))+NoLegend(), rel_widths = c(1,3), ncol=2)
```

### Mapping to Immgen
```{r fig.height=10, fig.width=20, echo=FALSE}
cowplot::plot_grid(
  results_of_annotation_by_reference[[paste0("cluster_0")]]$combined_plot,
  special_results_of_annotation_by_reference[[paste0("cluster_4_1")]]$combined_plot,
  special_results_of_annotation_by_reference[[paste0("cluster_4_2")]]$combined_plot,
  special_results_of_annotation_by_reference[[paste0("cluster_13")]]$combined_plot,
  ncol=2)

```

Markers used reference mapping:

#### Cluster 0
```{r echo=F}
top_markers_list[["cluster_0"]]
```

#### Cluster 4_1
markers of cluster 4_1 compared to all non B cells clusters
```{r echo=F}
special_top_markers_list[[paste0("cluster_4_1")]] %>% dt_table()
```

#### Cluster 4_2
markers of cluster 4_2 compared to all non B cells clusters
```{r echo=F}
special_top_markers_list[[paste0("cluster_4_2")]] %>% dt_table()
```
### Cluster 13

```{r echo=F}
special_top_markers_list[[paste0("cluster_13")]] %>% dt_table()
```

## T cells

Cluster 1, 2 3, 4_0, 12, 7_1 are T cells.

### Known markers
```{r echo=F, fig.width=20, fig.height=5}
cowplot::plot_grid(FeaturePlot(seurat_objects.combined, min.cutoff = .1,
            features = c("Cd3e"), label=T),
VlnPlot(seurat_objects.combined, pt.size=0, features=c("Cd3e", "Cd4","Cd8a"))+NoLegend(), rel_widths = c(1,3), ncol=2)
```

### Mapping to Immgen
```{r fig.height=15, fig.width=20, echo=FALSE}
cowplot::plot_grid(
  results_of_annotation_by_reference[[paste0("cluster_1")]]$combined_plot,
  results_of_annotation_by_reference[[paste0("cluster_2")]]$combined_plot,
  results_of_annotation_by_reference[[paste0("cluster_3")]]$combined_plot,
  special_results_of_annotation_by_reference[[paste0("cluster_4_0")]]$combined_plot,
  results_of_annotation_by_reference[[paste0("cluster_12")]]$combined_plot,
  results_of_annotation_by_reference[[paste0("cluster_7_1")]]$combined_plot,
  ncol=2)

```

### Cluster 1
CD4+ T-cells
```{r echo=F}
top_markers_list[["cluster_1"]] %>% dt_table()
```

### Cluster 2
CD8+ T-cells
```{r echo=F}
top_markers_list[["cluster_2"]] %>% dt_table()
```

### Cluster 3
Double negative T-cells
```{r echo=F}
top_markers_list[["cluster_3"]] %>% dt_table()
```

### Cluster 4_0
Proliferating T-cells (CD8+)

comparing this clusters to all other the proliferation markers are very enriched
```{r echo=F}
top_markers_list[[paste0("cluster_4_0")]] %>% dt_table()
```

Comparing this cluster to all non-T cells clusters, the markers are:
```{r}
special_top_markers_list[[paste0("cluster_4_0")]] %>% dt_table()
```

### Cluster 12
Proliferating T-cells (CD8+)

comparing this clusters to all other the proliferation markers are very enriched
```{r echo=F}
top_markers_list[[paste0("cluster_12")]] %>% dt_table()
```


### Cluster 7_1
Natural Killer T-Cells
```{r}
top_markers_list[["cluster_7_1"]] %>% dt_table()
```

## NK cells

Cluster 7_0 is NK cells.

### Immgen mapping
```{r fig.height=5, fig.width=20, echo=FALSE}
results_of_annotation_by_reference[[paste0("cluster_7_0")]]$combined_plot
```

#### Markers used.
```{r echo=F}
top_markers_list[[paste0("cluster_7_0")]] %>% dt_table()
```

## Macrophages
Cluster 10 is macrophages. These are likely tissue-resident macrophages 
(some characterstics of red pulp macrophages (see below))

### Immgen mapping
```{r fig.height=5, fig.width=20, echo=FALSE}
results_of_annotation_by_reference[[paste0("cluster_10")]]$combined_plot
```

#### Markers used
```{r echo=F}
top_markers_list[[paste0("cluster_10")]] %>% dt_table()
```

### Core Red pulp macrophages markers
RpMΦs form a vast network inside the Rp and are characterized in mice by 
expression of F4/80highCD68+CD11blow/− and intense autofluorescence (AF) See:
Borges da Silva H, Fonseca R, Pereira RM, Cassado Ados A, Álvarez JM, D'Império
Lima MR. Splenic Macrophage Subsets and Their Function during Blood-Borne Infections. 
(See: Front Immunol. 2015 Sep 22;6:480. doi: 10.3389/fimmu.2015.00480. PMID: 
26441984; PMCID: PMC4585205.) 

F4/80 ist also called Adgre1, CD11b is called Itgam. By plotting the expression 
of these markers we can see that the RpMΦs are indeed cluster 6 as inferred by 
our annotation algorithm based on ImmGen-Database.

```{r echo=F, fig.width=15, fig.height=5, warning=F}
VlnPlot(seurat_objects.combined, 
       pt.size=0,
            features = c("Adgre1", "Cd68", "Itgam"), ncol=3)
```

## Dendritic cells (DC)
Cluster 8 and 11 are dendritic cells


### Some selected markers
For both or one of these clusters. 
```{r fig.height=5, fig.width=20, echo=FALSE}
cowplot::plot_grid(FeaturePlot(seurat_objects.combined, min.cutoff = .1,
            features = c("Itgax") , label=T)+ ggtitle("Itgax (CD11c)"),
VlnPlot(seurat_objects.combined, pt.size=0, features=c("Itgax", "Flt3", "Sirpa", "Xcr1", "Cd8a"))+NoLegend(), rel_widths = c(1,3), ncol=2)
```


### Immgen mapping
```{r fig.height=5, fig.width=20, echo=FALSE}
results_of_annotation_by_reference[[paste0("cluster_8")]]$combined_plot
```

```{r fig.height=5, fig.width=20, echo=FALSE}
results_of_annotation_by_reference[[paste0("cluster_11")]]$combined_plot
```

### Markers used
```{r echo=F}
top_markers_list[[paste0("cluster_8")]] %>% dt_table()
```

```{r echo=F}
top_markers_list[[paste0("cluster_11")]] %>% dt_table()
```

## Monocytes
Cluster 6 is monocytes.


### Known markers
```{r fig.height=5, fig.width=20, echo=FALSE}
cowplot::plot_grid(FeaturePlot(seurat_objects.combined, min.cutoff = .1,
            features = c("Itgam", "Ly6c2") , label=T, ncol=1),
VlnPlot(seurat_objects.combined, pt.size=0, features=c("Itgam", "Ly6c2", "Ccr2", "Cx3cr1", "Csf1r"))+NoLegend(), rel_widths = c(1,3), ncol=2)
```



### Immgen mapping
```{r fig.height=5, fig.width=20, echo=FALSE}
results_of_annotation_by_reference[[paste0("cluster_6")]]$combined_plot
```

### Markers used
```{r echo=F}
top_markers_list[[paste0("cluster_6")]] %>% dt_table()
```

## Neutrophils

Cluster 5 is neutrophils.

### Known markers
```{r fig.height=5, fig.width=20, echo=FALSE}
cowplot::plot_grid(FeaturePlot(seurat_objects.combined, min.cutoff = .1,
            features = c("Itgam", "Ly6g") , label=T, ncol=1),
VlnPlot(seurat_objects.combined, pt.size=0, features= c("Ly6g", "Itgam", "Cxcr2", "Lyz2", "S100a8", "S100a9", "Mmp9")
)+NoLegend(), rel_widths = c(1,3), ncol=2)
```

### Immgen mapping
```{r fig.height=5, fig.width=20, echo=FALSE}
results_of_annotation_by_reference[[paste0("cluster_5")]]$combined_plot
```

### Markers used
```{r echo=F}
top_markers_list[[paste0("cluster_5")]] %>% dt_table()
```

## Erythroid cells

Cluster 9 is erythroid cells. This cluster seems to contain multiple subpopulations
of erythroid cells. In the Immgen dataset these cell types are missing. It was
detected as similar to stem-cells. Mostly because of the high expression of
of progenitor and proliferation markers.


### Known markers
```{r fig.height=5, fig.width=20, echo=FALSE}
cowplot::plot_grid(FeaturePlot(seurat_objects.combined, min.cutoff = .1,
            features = c("Hbb-bt", "Hba-a1") , label=T, ncol=1),
VlnPlot(seurat_objects.combined, pt.size=0, features= c("Hbb-bt", "Hba-a1", "Gypa", "Slc4a1", "Klf1", "Gata1")
)+NoLegend(), rel_widths = c(1,3), ncol=2)
```

### Erythroid lineage markers
```{r fig.height=5, fig.width=20, echo=FALSE}
library(ggplot2)
# Erythroid lineage markers (surface, structural, and transcription factors)
erythroid_lineage_markers <- c(
  "Gypa",    # Glycophorin A: Erythroid-specific surface protein.
  "Hba-a1",  # Hemoglobin alpha chain.
  "Hba-a2",  # Hemoglobin alpha chain.
  "Hbb-bt",  # Hemoglobin beta chain.
  "Hbb-bs",  # Hemoglobin beta chain.
  "Gata1",   # Master transcription factor for erythropoiesis.
  "Klf1",    # Critical erythroid transcription factor.
  "Epor",    # Erythropoietin receptor: Essential for red cell proliferation.
  "Tfrc",    # Transferrin receptor: Indicates active iron uptake.
  "Spta1",   # Spectrin alpha: Important for erythrocyte membrane structure.
  "Ank1",    # Ankyrin 1: Membrane protein in red blood cells.
  "Slc4a1"  # Band 3 anion exchanger: Key in erythrocyte function.
)
VlnPlot(seurat_objects.combined, pt.size=0, features= erythroid_lineage_markers
)+NoLegend()



```

### Terminal erythrocyte markers
```{r fig.height=5, fig.width=20, echo=FALSE}

terminal_erythrocyte_markers <- c("Gypa", "Spta1", "Ank1", "Slc4a1")

VlnPlot(seurat_objects.combined, pt.size=0, features= terminal_erythrocyte_markers, ncol=4
)+NoLegend()


```

### Early erythroid progenitor markers
```{r fig.height=5, fig.width=20, echo=FALSE}
early_erythroid_progenitor_markers <- c(
  "Tal1",   # Critical transcription factor for early hematopoiesis and erythroid commitment.
  "Gfi1b",  # Transcriptional regulator required for erythroid maturation, enriched in early progenitors.
  "Lmo2"    # Involved in early blood development and enriched in progenitor cells.
)

VlnPlot(seurat_objects.combined, pt.size=0, features= early_erythroid_progenitor_markers, ncol=4
)+NoLegend()



```


### Proliferating erythroblast markers
```{r fig.height=5, fig.width=20, echo=FALSE}
proliferating_erythroblast_markers <- c(
  "Mki67",  # A classic proliferation marker (expressed only in cycling, nucleated cells).
  "Cdk1",   # Cell cycle regulator, active in proliferating erythroblasts.
  "Plk1",   # Involved in mitosis and cell division.
  "Epor"    # Erythropoietin receptor; expressed in erythroid precursors and downregulated in mature erythrocytes.
)

VlnPlot(seurat_objects.combined, pt.size=0, features= proliferating_erythroblast_markers,ncol=4
)+NoLegend()
```


### top markers
```{r echo=F}
top_markers_list[[paste0("cluster_9")]]  %>% dt_table()
```


## Note
I steems that B-cells clusters 4_1, and 4_2 and T-cell Cluster 4_0 clustered 
together first to very similar proliferation profiles. Also cluster 9 (erythroid) 
show high level of proliferation.

```{r echo=F}
Idents(seurat_objects.combined) <- "integrated_snn_res.0.1_and_cluster_4_and_cluster_9"
VlnPlot(seurat_objects.combined, pt.size=0, features = c("Top2a", "Mki67"))
```

## Summary of annotation

```{r echo=F}
# Original broad.annotation.map:
# "T"="4_0", "Neutro"="5", "Erythroid"="9", "Mono"="6", 
# "T"="2", "T"="1", "DC"="11", "T"="3", "B"="0", "DC"="8", 
# "T"="7_1", "B"="4_2", "MF"="10", "T"="12", "NK"="7_0", "B"="13", "B"="4_1"

# Manually swapped (values become names, names become values):
broad_annotation_map <- c(
  "4_0" = "T",
  "5"   = "Neutro",
  "9"   = "Erythroid",
  "6"   = "Mono",
  "2"   = "T",
  "1"   = "T",
  "11"  = "DC",
  "3"   = "T",
  "0"   = "B",
  "8"   = "DC",
  "7_1" = "T",
  "4_2" = "B",
  "10"  = "MF",
  "12"  = "T",
  "7_0" = "NK",
  "13"  = "B",
  "4_1" = "B"
)

# Original T.refined.annotation.map:
# "prolif. T"="4_0", "Neutro"="5", "Erythroid"="9", "Mono"="6", 
# "CD8+ T"="2", "CD4+ T"="1", "DC"="11", "DN-T"="3", "B"="0", 
# "DC"="8", "NKT"="7_1", "B"="4_2", "MF"="10", "CD4+ T"="12", 
# "NK"="7_0", "B"="13", "B"="4_1"

# Manually swapped:
T_refined_annotation_map <- c(
  "4_0" = "prolif. T",
  "5"   = "Neutro",
  "9"   = "Erythroid",
  "6"   = "Mono",
  "2"   = "CD8+ T",
  "1"   = "CD4+ T",
  "11"  = "DC",
  "3"   = "DN-T",
  "0"   = "B",
  "8"   = "DC",
  "7_1" = "NKT",
  "4_2" = "B",
  "10"  = "MF",
  "12"  = "CD4+ T",
  "7_0" = "NK",
  "13"  = "B",
  "4_1" = "B"
)





seurat_objects.combined@meta.data$cell_type <- broad_annotation_map[seurat_objects.combined$integrated_snn_res.0.1_and_cluster_4_and_cluster_9]
seurat_objects.combined@meta.data$cell_type.fine <- T_refined_annotation_map[seurat_objects.combined$integrated_snn_res.0.1_and_cluster_4_and_cluster_9]


DimPlot(seurat_objects.combined, group.by = "cell_type", label=T) + NoLegend() + ggtitle("Broad annotation")
DimPlot(seurat_objects.combined, group.by = "cell_type.fine", label=T) + NoLegend() + ggtitle("T-cell Refined annotation")
```
```{r fig.width=20, fig.height=5, include=F}
 Stem          = c("Adgrg1", "Gata2", "Cpa3")
seurat_objects.combined <- AddModuleScore(seurat_objects.combined, list(Stem), name = "Stem")
VlnPlot(seurat_objects.combined, features = "Gata2")

Idents(seurat_objects.combined) <- "integrated_snn_res.0.1_and_cluster_4_and_cluster_9"
seurat_objects.combined <- FindSubCluster(seurat_objects.combined, cluster = "9", subcluster.name = "Stem", graph.name = "integrated_snn", resolution = 0.01)

Idents(seurat_objects.combined) <- "Stem"
  Erythrocytes  = c("Car1", "Car2", "Hmbs", "Cpox")

erythroid_markers <- c("Gata1", "Klf1", "Tfrc", "Ter119", "Hba-a1", "Hbb-bt", "Hbb-bs")

proliferating_erythroblast_markers


VlnPlot(seurat_objects.combined, features = "Stem1", pt.size=0)
  VlnPlot(seurat_objects.combined, features = Erythrocytes, pt.size=0, ncol=4)
  VlnPlot(seurat_objects.combined, features = erythroid_markers, pt.size=0, ncol=4)
  VlnPlot(seurat_objects.combined, features = proliferating_erythroblast_markers, pt.size=0, ncol=4)
  VlnPlot(seurat_objects.combined, features = Stem, pt.size=0, ncol=4)


DimPlot(seurat_objects.combined %>% subset(subset=integrated_snn_res.0.1_and_cluster_4_and_cluster_9==9), split.by = "Stem", label=T) + NoLegend()
DimPlot(seurat_objects.combined, label=T) + NoLegend()

erythroid_so <- seurat_objects.combined %>% subset(subset=integrated_snn_res.0.1_and_cluster_4_and_cluster_9 == "9")
erythroid_so_markers <- FindAllMarkers(erythroid_so, only.pos = TRUE, min.pct = 0.25, logfc.threshold = log2(1.5))
erythroid_markers_list <- erythroid_so_markers %>% dplyr::filter(avg_log2FC > 1, p_val_adj < 0.05 ) %>% group_by(cluster) %>% top_n(wt=avg_log2FC, n=20) %>% dplyr::group_split(cluster) 

erythroid_markers_list 

table(erythroid_so$Stem, erythroid_so$orig.ident)

markers_9.0 <- FindMarkers(seurat_objects.combined, ident.1="9_0", only.pos=T, min.pct=0.25, logfc.threshold=log2(1.5))
markers_9.1 <- FindMarkers(seurat_objects.combined, ident.1="9_1", only.pos=T, min.pct=0.25, logfc.threshold=log2(1.5))
markers_9.2 <- FindMarkers(seurat_objects.combined, ident.1="9_2", only.pos=T, min.pct=0.25, logfc.threshold=log2(1.5))
markers_9.3 <- FindMarkers(seurat_objects.combined, ident.1="9_3", only.pos=T, min.pct=0.25, logfc.threshold=log2(1.5))

markers_9.3 %>% dplyr::filter(p_val_adj < 0.05 & avg_log2FC > 1) %>% dplyr::arrange(desc(avg_log2FC)) %>% add_column(gene=rownames(.)) %>% pull(gene)
markers_9.2 %>% dplyr::filter(p_val_adj < 0.05 & avg_log2FC > 1) %>% dplyr::arrange(desc(avg_log2FC)) %>% add_column(gene=rownames(.)) %>% pull(gene)
markers_9.1 %>% dplyr::filter(p_val_adj < 0.05 & avg_log2FC > 1) %>% dplyr::arrange(desc(avg_log2FC)) %>% add_column(gene=rownames(.)) %>% pull(gene)
markers_9.0 %>% dplyr::filter(p_val_adj < 0.05 & avg_log2FC > 1) %>% dplyr::arrange(desc(avg_log2FC)) %>% add_column(gene=rownames(.)) %>% pull(gene)

markers_9_0_vs_9_1 <-  FindMarkers(seurat_objects.combined, ident.1="9_0", ident.2="9_1", min.pct=0.25, logfc.threshold=log2(1.5))

markers_9_0_vs_9_1 %>% dplyr::filter(avg_log2FC>1 & p_val_adj < .05 & pct.1-pct.2>.5)
markers_9_0_vs_9_1 %>% dplyr::filter(avg_log2FC< -1 & p_val_adj < .05) %>% add_column(gene=rownames(.)) %>% pull(gene)

VlnPlot(seurat_objects.combined, features="Stem1")

VlnPlot(erythroid_so, features = c("Gata1", "Klf1", "Tfrc", "Ter119", "Hba-a1", "Hbb-bt", "Hbb-bs"), pt.size = 0)
VlnPlot(erythroid_so, features = erythroid_lineage_markers, pt.size = 0)
```

```{r}
# Load required libraries
library(Seurat)
library(ggplot2)
library(dplyr)

# Version 1: Using cell_type
# Calculate cell type proportions for each sample
cell_prop <- seurat_objects.combined@meta.data %>%
  group_by(orig.ident, cell_type) %>%
  summarise(count = n()) %>%
  mutate(proportion = count / sum(count) * 100) %>%
  ungroup()

# Create pie charts for each sample
ggplot(cell_prop, aes(x = "", y = proportion, fill = cell_type)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) +
  facet_wrap(~orig.ident, ncol = 3) +  # Creates 3x3 grid for 9 samples
  theme_void() +  # Removes background elements
  labs(fill = "Cell Type") +
  ggtitle("Cell Type Composition Across Samples")

# Version 2: Using cell_type.fine
# Calculate cell type proportions for each sample with finer annotation
cell_prop_fine <- seurat_objects.combined@meta.data %>%
  group_by(orig.ident, cell_type.fine) %>%
  summarise(count = n()) %>%
  mutate(proportion = count / sum(count) * 100) %>%
  ungroup()

# Create pie charts for each sample with finer annotation
ggplot(cell_prop_fine, aes(x = "", y = proportion, fill = cell_type.fine)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y", start = 0) +
  facet_wrap(~orig.ident, ncol = 3) +
  theme_void() +
  labs(fill = "Cell Type (Fine)") +
  ggtitle("Detailed Cell Type Composition Across Samples")

# Optional: Save the plots
ggsave("cell_type_pie_charts.png", width = 12, height = 12)
ggsave("cell_type_fine_pie_charts.png", width = 12, height = 12)
```

```{r}
# Load required libraries
library(Seurat)
library(ggplot2)
library(dplyr)
library(ggrepel)

create_pie_chart_lists <- function(seurat_obj) {
  # Initialize lists to store plots
  cell_type_plots <- list()
  cell_type_fine_plots <- list()
  
  # Function to create plots for a given annotation column
  create_plots <- function(annotation_col) {
    # Calculate proportions and prepare data with label positions
    cell_prop <- seurat_obj@meta.data %>%
      group_by(orig.ident, !!sym(annotation_col)) %>%
      summarise(count = n()) %>%
      mutate(proportion = count / sum(count) * 100,
             prop_label = sprintf("%.1f%%", proportion),
             # Calculate angles and positions for labels
             cumprop = cumsum(proportion) - 0.5 * proportion,
             angle = 2 * pi * (cumprop / 100),
             # Convert to cartesian coordinates for outside placement
             x = 1.2 * cos(angle),  # 1.2 units outside pie (radius = 1)
             y = 1.2 * sin(angle)) %>%
      ungroup()
    
    # Split by sample
    samples <- unique(cell_prop$orig.ident)
    
    # Create plots and store in a list
    plot_list <- list()
    for(sample in samples) {
      sample_data <- filter(cell_prop, orig.ident == sample)
      
      p <- ggplot(sample_data, aes(x = 1, y = proportion, fill = !!sym(annotation_col))) +
        geom_bar(stat = "identity") +
        coord_polar(theta = "y", start = 0) +
        geom_text_repel(
          aes(x = 1, y = proportion/2,  # Start at pie edge, middle of slice
              label = paste(!!sym(annotation_col), prop_label, sep = "\n")),
          nudge_x = sample_data$x,  # Use pre-calculated x positions
          nudge_y = sample_data$y,  # Use pre-calculated y positions
          direction = "both",
          box.padding = 0.5,
          point.padding = 0.5,
          segment.color = "grey50",
          size = 3,
          max.overlaps = Inf
        ) +
        theme_void() +
        ggtitle(sample) +
        theme(legend.position = "none") +
        expand_limits(x = c(-2, 2), y = c(-2, 2))  # Space for labels
    
      plot_list[[sample]] <- p
    }
    return(plot_list)
  }
  
  # Generate plots for both annotation types
  cell_type_plots <- create_plots("cell_type")
  cell_type_fine_plots <- create_plots("cell_type.fine")
  
  # Return both lists in a named list
  return(list(
    cell_type = cell_type_plots,
    cell_type_fine = cell_type_fine_plots
  ))
}

# Create the plot lists
plot_lists <- create_pie_chart_lists(seurat_objects.combined)

# Usage examples:
# View a specific plot: plot_lists$cell_type[["sample_name"]]
# View all cell_type plots: lapply(plot_lists$cell_type, print)
# View all cell_type.fine plots: lapply(plot_lists$cell_type_fine, print)
```

```{r}
library(Seurat)
library(dplyr)
library(plotly)

# Extract metadata from the Seurat object
meta <- seurat_objects.combined@meta.data

# Choose the annotation column (e.g., "cell_type" or "cell_type.fine")
cell_type_col <- "cell_type"

# Create a new column "Group" for easier referencing
meta <- meta %>%
  mutate(Group = .data[[cell_type_col]])

# Summarize the data: count cells for each sample and cell type
df <- meta %>%
  group_by(orig.ident, Group) %>%
  summarise(count = n(), .groups = "drop")

# Get unique sample names
unique_samples <- unique(df$orig.ident)

# Loop through each sample to generate an interactive pie chart
plot_list <- list()
for (sample in unique_samples) {
  # Filter data for the current sample
  df_sample <- df %>% filter(orig.ident == sample)
  
  # Create the pie chart
  p <- plot_ly(
    data = df_sample,
    labels = ~Group,
    values = ~count,
    type = "pie",
    textposition = "outside",
    textinfo = "label+percent"  # Show both labels and percentage
  ) %>%
    layout(
      title = paste("Cell Composition for Sample", sample),
      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE)
    )
  
  # Display the plot (in an interactive session) and store it in a list if needed
  print(p)
  plot_list[[sample]] <- p
}

```

```{r}
library(Seurat)
library(dplyr)
library(plotly)

# Extract metadata from the Seurat object
meta <- seurat_objects.combined@meta.data

# Choose the annotation column (e.g., "cell_type" or "cell_type.fine")
cell_type_col <- "cell_type"

# Create a new column "Group" for easier referencing
meta <- meta %>%
  mutate(Group = .data[[cell_type_col]])

# Summarize the data: count cells for each sample and cell type
df <- meta %>%
  group_by(orig.ident, Group) %>%
  summarise(count = n(), .groups = "drop")

# Identify all unique cell types (Groups)
all_cell_types <- sort(unique(df$Group))

# Create a color palette. You can use any palette you like (RColorBrewer, etc.)
# Example: RColorBrewer's "Set3" with enough colors for all cell types
library(RColorBrewer)
my_colors <- brewer.pal(n = max(length(all_cell_types), 3), name = "Set3")

# Create a named vector: each cell type -> one color
color_map <- setNames(my_colors[seq_along(all_cell_types)], all_cell_types)

# Get unique sample names
unique_samples <- unique(df$orig.ident)

# Loop through each sample to generate an interactive pie chart
plot_list <- list()
for (sample in unique_samples) {
  # Filter data for the current sample
  df_sample <- df %>% filter(orig.ident == sample)
  
  # Build the pie chart
  # 'marker' controls the slice colors. We subset 'color_map' to match each cell type.
  p <- plot_ly(
    data = df_sample,
    labels = ~Group,
    values = ~count,
    type = "pie",
    textposition = "outside",
    textinfo = "label+percent",
    marker = list(colors = color_map[df_sample$Group])  # Consistent color mapping
  ) %>%
   layout(
  title = paste("Cell Composition for Sample", sample),
  margin = list(l = 100, r = 100, b = 250, t = 100),
  xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
  yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE)
  ,width = 600,    # Increase width of the plot area
      height = 600# Increase height of the plot area
)
  # Print or store the plot
  print(p)
  plot_list[[sample]] <- p
}


  plot_list[[sample]] 
```

```{r}
library(Seurat)
library(dplyr)
library(plotly)
library(RColorBrewer)

# Extract metadata from the Seurat object
meta <- seurat_objects.combined@meta.data

# Choose the annotation column (e.g., "cell_type" or "cell_type.fine")
cell_type_col <- "cell_type"

# Create a new column "Group" for easier referencing
meta <- meta %>% mutate(Group = .data[[cell_type_col]])

# Summarize the data: count cells for each sample and cell type
df <- meta %>%
  group_by(orig.ident, Group) %>%
  summarise(count = n(), .groups = "drop")

# Identify all unique cell types (Groups) and assign consistent colors
all_cell_types <- sort(unique(df$Group))
my_colors <- brewer.pal(n = max(length(all_cell_types), 3), name = "Set3")
color_map <- setNames(my_colors[seq_along(all_cell_types)], all_cell_types)

# Get unique sample names
unique_samples <- unique(df$orig.ident)

plot_list <- list()
for (sample in unique_samples) {
  # Filter data for the current sample
  df_sample <- df %>% filter(orig.ident == sample)
  total <- sum(df_sample$count)
  
  # Sort slices alphabetically by cell type and calculate fractions and angles
  df_sample <- df_sample %>% arrange(Group) %>%
    mutate(
      frac = count / total,
      cumulative = cumsum(frac),
      prev = lag(cumulative, default = 0),
      mid = prev + frac / 2,   # midpoint fraction
      angle = mid * 360        # mid-angle in degrees
    )
  
  # Assume the pie is centered at (0.5, 0.5) and choose a radius (r) for placing annotations
  r <- 0.7
  df_sample <- df_sample %>%
    mutate(
      angle_rad = angle * pi / 180,  # convert to radians
      ann_x = 0.5 + r * cos(angle_rad),
      ann_y = 0.5 + r * sin(angle_rad)
    )
  
  # Create custom annotations with text rotated 45°.
  annotations <- lapply(1:nrow(df_sample), function(i) {
    list(
      x = df_sample$ann_x[i],
      y = df_sample$ann_y[i],
      text = paste0(df_sample$Group[i], " (", round(df_sample$frac[i] * 100, 1), "%)"),
      showarrow = TRUE,
      arrowhead = 1,
      ax = 0,
      ay = 0,
      textangle = 45,
      font = list(size = 12)
    )
  })
  
  # Build the pie chart; disable default text info.
  p <- plot_ly(
    data = df_sample,
    labels = ~Group,
    values = ~count,
    type = "pie",
    textinfo = "none",   # remove default outside labels
    marker = list(colors = color_map[df_sample$Group])
  ) %>%
    layout(
      title = paste("Cell Composition for Sample", sample),
      margin = list(l = 100, r = 100, b = 100, t = 100),
      width = 600,
      height = 600,
      annotations = annotations
    )
  
  print(p)
  plot_list[[sample]] <- p
}

```


```{r}
library(Seurat)
library(dplyr)
library(plotly)
library(RColorBrewer)

# Extract metadata from the Seurat object
meta <- seurat_objects.combined@meta.data

# Choose the annotation column (e.g., "cell_type" or "cell_type.fine")
cell_type_col <- "cell_type"

# Create a new column "Group" for easier referencing
meta <- meta %>% mutate(Group = .data[[cell_type_col]])

# Summarize the data: count cells for each sample and cell type
df <- meta %>%
  group_by(orig.ident, Group) %>%
  summarise(count = n(), .groups = "drop")

# Identify all unique cell types (Groups) and assign consistent colors
all_cell_types <- sort(unique(df$Group))
my_colors <- brewer.pal(n = max(length(all_cell_types), 3), name = "Set3")
color_map <- setNames(my_colors[seq_along(all_cell_types)], all_cell_types)

# Get unique sample names
unique_samples <- unique(df$orig.ident)

# Loop through each sample to generate an interactive pie chart
plot_list <- list()
for (sample in unique_samples) {
  # Filter data for the current sample
  df_sample <- df %>% filter(orig.ident == sample)
  
  # Build the pie chart using default annotation (labels placed outside)
  p <- plot_ly(
    data = df_sample,
    labels = ~Group,
    values = ~count,
    type = "pie",
    textposition = "outside",
    textinfo = "label+percent",
    marker = list(colors = color_map[df_sample$Group])
  ) %>%
    layout(
      title = paste("Cell Composition for Sample", sample),
      margin = list(l = 100, r = 100, b = 250, t = 100),
      xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
      yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),
      width = 600,
      height = 600
    )
  
  print(p)
  plot_list[[sample]] <- p
}

```



```{r fig.height=15, fig.width=20, echo=F}
cowplot::plot_grid(
  
  seurat_objects.combined %>% 
    subset(subset=orig.ident %in% c("WTR1", "WTR2", "WTR3", "WTR4")) %>% 
    DimPlot(split.by = "orig.ident", pt.size=1, label=T, ncol=4),
  
  cowplot::plot_grid(
  seurat_objects.combined %>% 
    subset(subset=orig.ident %in% c("CSR1", "CSR2", "CSR3")) %>% 
    DimPlot(split.by = "orig.ident", pt.size=1, label=T, ncol=3), 
  ggplot()+theme_void(), rel_widths = c(3,1)
  ),
  
  cowplot::plot_grid(
  seurat_objects.combined %>% 
    subset(subset=orig.ident %in% c("KOR1", "KOR2")) %>% 
    DimPlot(split.by = "orig.ident", pt.size=.5, label=T, ncol=2),
  ggplot()+theme_void(),
  ggplot()+theme_void(),
  rel_widths = c(2,1,1), ncol=3
  ), 
  
  
  ncol=1)
```

```{r}

ccdf <- table(seurat_objects.combined$cell_type.fine, seurat_objects.combined$orig.ident) %>% as.data.frame.matrix() 

#for(i in 1:12){
#  ccdf[i,] <- ccdf[i,]/sum(ccdf[i,])
#}
for(i in 1:9){
  ccdf[,i] <- round(100*ccdf[,i]/sum(ccdf[,i]),2)
}

ccdf <- log2(ccdf)
ccdf <- ccdf - rowMedians(as.matrix(ccdf))
ccdf <- ccdf - rowMedians(as.matrix(ccdf))
ccds <- scale(ccdf, center = TRUE, scale = TRUE)

# make the table in long format for ggplot
ccdf <- as.data.frame(ccdf)
ccdf$cell_type.fine <- rownames(ccdf)
ccdf <- ccdf %>% gather(key = "orig.ident", value = "zscore_log2_count", -cell_type.fine)

#

# plot the heatmap

ggplot(ccdf, aes(x = orig.ident, y = cell_type.fine, fill = zscore_log2_count)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "darkblue", mid = "white", high = "red") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Heatmap of Cell Type Composition", x = "Sample", y = "Cell Type") +
  coord_fixed(ratio = 0.5) + geom_vline(xintercept = c(3.5,5.5), color="grey")+
  theme(plot.title=element_text(hjust=.5, face="bold"))



```

```{r fig.width=5, fig.height=5}
ccdf <- table(seurat_objects.combined$cell_type.fine, seurat_objects.combined$orig.ident) %>% as.data.frame.matrix() 
for(i in 1:9){
  ccdf[,i] <- round(100*ccdf[,i]/sum(ccdf[,i]),1)
}
#ccdf <- ccdf[,-1]
desired_order <- c("B",    "prolif. T" ,  "DN-T" ,    "CD4+ T" ,   "CD8+ T",    "NKT" ,  "NK" ,   "DC" ,            "MF" ,       "Mono"   ,   "Neutro" ,    "Erythroid" )  # replace with your actual row names
rownames(ccdf)
# Reorder your data matrix based on the desired order
ordered_ccdf <- ccdf[desired_order, ]

# If you are displaying original values, reorder that matrix too:
ordered_display_numbers <- ccdf[desired_order, ]

pheatmap::pheatmap(ordered_ccdf, scale="row", border_color = "white", cluster_rows = F, display_numbers = ordered_display_numbers,number_color= "black" )
pheatmap::pheatmap(ordered_ccdf, scale="column",clustering_distance_rows="manhattan", border_color = "white", cluster_rows = F, cluster_cols = T, display_numbers = ordered_display_numbers,number_color= "black" )

```


```{r}
seurat_objects.combined.full <- seurat_objects.combined

DimPlot(seurat_objects.combined.full)

```

```{r}
seurat_objects.combined.full@meta.data
```


```{r fig.height=15, fig.width=20, echo=F}

Idents(seurat_objects.combined.full) <- "cell_type.fine"
cowplot::plot_grid(
  
  seurat_objects.combined.full %>% 
    subset(subset=orig.ident %in% c("WTR1", "WTR2", "WTR3", "WTR4")) %>% 
    DimPlot(split.by = "orig.ident", pt.size=1, label=T, ncol=4),
  
  cowplot::plot_grid(
  seurat_objects.combined.full %>% 
    subset(subset=orig.ident %in% c("CSR1", "CSR2", "CSR3")) %>% 
    DimPlot(split.by = "orig.ident", pt.size=1, label=T, ncol=3), 
  ggplot()+theme_void(), rel_widths = c(3,1)
  ),
  
  cowplot::plot_grid(
  seurat_objects.combined.full %>% 
    subset(subset=orig.ident %in% c("KOR1", "KOR2")) %>% 
    DimPlot(split.by = "orig.ident", pt.size=1, label=T, ncol=2),
  ggplot()+theme_void(),
  ggplot()+theme_void(),
  rel_widths = c(2,1,1), ncol=3
  ), 
  
  
  ncol=1)

```


```{r}
seurat_objects.combined.full <- seurat_objects.combined.full %>% AddMetaData(seurat_objects.combined@meta.data[,c("orig.ident", "cell_type.fine")])
```


```{r fig.width=10, fig.height=10}
Stem=c("Adgrg1", "Gata2", "Cpa3")
Idents(seurat_objects.combined) 
VlnPlot(seurat_objects.combined, features="Stem1")
seurat_objects.combined_cluster_9 <-  seurat_objects.combined %>% 
    subset(subset=integrated_snn_res.0.1_and_cluster_4_and_cluster_9 %in% "9")

Idents(seurat_objects.combined) <- "cell_type.fine"

cowplot::plot_grid(
cowplot::plot_grid(
  FeaturePlot(seurat_objects.combined_cluster_9
 , 
  features="Stem1", label=T)+ggtitle("Stem markers (Adgrg1, Gata2, Cpa3)"),
DimPlot(seurat_objects.combined_cluster_9),
ncol=2),cowplot::plot_grid(VlnPlot(seurat_objects.combined_cluster_9, 
  features=Stem),VlnPlot(
  seurat_objects.combined, 
  features=Stem),ncol=1)
,ncol=1)




seurat_objects.combined$integrated_snn_res.0.1_and_cluster_4_and_cluster_9 %>% table()
```


```{r fig.width=12, fig.height=4}
VlnPlot(
  seurat_objects.combined %>% 
    subset(subset=integrated_snn_res.0.1_and_cluster_4_and_cluster_9 %in% "9"), 
  features=Stem)
```

```{r}
qs::qsave(seurat_objects.combined.full, "results/seurat_objects.combined.cleansed.annotated.250428.qs")
```

